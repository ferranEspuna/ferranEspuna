---
layout: default
title: Newton's Fractal
---

<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

  <style>
    body {
      text-align: center;
      margin: 0;
      padding: 2em;
      overflow-y: auto;
      /* allow scrolling */
      overflow-x: hidden;
    }

    nav {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
    }

    .shader-window {
      max-width: 800px;
      margin: 0 auto;
    }

    canvas {
      display: block;
      width: 100%;
      aspect-ratio: 1/1;
      border-radius: 0.5em;
      cursor: crosshair;
      touch-action: none;
      /* needed for multi-touch */
    }

    .controls {
      margin-top: 1em;
    }

    .description {
      max-width: 800px;
      margin: 1em auto 2em auto;
      font-size: 0.95em;
      line-height: 1.5em;
      text-align: left;
    }

    .description code {
      padding: 0.15em 0.3em;
      border-radius: 0.25em;
    }

    button {
      padding: 0.4em 0.8em;
      border-radius: 0.3em;
      cursor: pointer;
      margin-top: 0.5em;
      font-size: 0.9em;
      transition: background 0.2s;
    }

    .canvas-wrapper {
      position: relative;
      width: 100%;
      /* aspect-ratio: 1/1; Remove this to let content dictate, or keep? Canvas has it. */
    }

    .canvas-wrapper:fullscreen {
      width: 100vw;
      height: 100vh;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .canvas-wrapper:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fullscreen-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 20;
      opacity: 0.7;
      background: rgba(255, 255, 255, 0.8);
      border: none;
      font-weight: bold;
    }

    .fullscreen-btn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 1);
    }

    canvas:fullscreen {
      /* Reset canvas fullscreen styles as we wrapper is now fullscreen */
      width: 100% !important;
      height: 100% !important;
      aspect-ratio: auto !important;
    }

    /* Also target the canvas when its parent wrapper is fullscreen */
    .canvas-wrapper:fullscreen canvas {
      width: 100% !important;
      height: 100% !important;
      aspect-ratio: auto !important;
      max-width: none !important;
      max-height: none !important;
    }

    .canvas-wrapper:-webkit-full-screen canvas {
      width: 100% !important;
      height: 100% !important;
      aspect-ratio: auto !important;
      max-width: none !important;
      max-height: none !important;
    }
  </style>
</head>

<body>

  <nav>
    <a href="../">&larr; About Me</a>
  </nav>

  <h1>Newton's Fractal</h1>

  <div class="description" id="description"></div>

  <div class="shader-container" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;">
    <div class="shader-window" style="flex: 1; min-width: 300px;">
      <h3>Phase Space</h3>
      <div class="canvas-wrapper" id="wrapperMain">
        <button id="fullscreenBtnMain" class="fullscreen-btn">Fullscreen</button>
        <canvas class="glslCanvas" id="mainCanvas" data-fragment-url="shader.frag"></canvas>
      </div>
    </div>
    <div class="shader-window" style="flex: 1; min-width: 300px;">
      <h3>Parameter Space</h3>
      <div class="canvas-wrapper" id="wrapperParam">
        <button id="fullscreenBtnParam" class="fullscreen-btn">Fullscreen</button>
        <canvas class="glslCanvas" id="paramCanvas" data-fragment-url="parameter_space.frag"></canvas>
      </div>
    </div>
  </div>

  <div class="controls">
    <label for="iterSlider">Iterations:</label>
    <input type="range" id="iterSlider" min="0" max="100" value="10">
    <span id="iterValue">10</span>
    <br>
    <input type="checkbox" id="showPathToggle" style="margin-top: 0.5em;">
    <label for="showPathToggle">Show Path</label>

    <span id="pathOriginControl" style="display: none; margin-left: 1em;">
      <input type="checkbox" id="pathOriginToggle">
      <label for="pathOriginToggle">Control Path Origin</label>
    </span>
    <span id="trackCenterControl" style="display: none; margin-left: 1em;">
      <input type="checkbox" id="trackCenterToggle">
      <label for="trackCenterToggle">Track Center</label>
    </span>
    </span>
    <br>
  </div>

  <script type="module">
    import GlslCanvas from "https://esm.run/glslCanvas";

    window.addEventListener("load", async () => {
      const canvas = document.getElementById("mainCanvas");
      const paramCanvas = document.getElementById("paramCanvas");
      const wrapperMain = document.getElementById("wrapperMain");
      const wrapperParam = document.getElementById("wrapperParam");
      const slider = document.getElementById("iterSlider");
      const iterDisplay = document.getElementById("iterValue");
      const fullscreenBtnMain = document.getElementById("fullscreenBtnMain");
      const fullscreenBtnParam = document.getElementById("fullscreenBtnParam");
      const descriptionEl = document.getElementById("description");
      // NEW DOM ELEMENTS
      const showPathToggle = document.getElementById("showPathToggle");
      const pathOriginControl = document.getElementById("pathOriginControl");
      const pathOriginToggle = document.getElementById("pathOriginToggle");
      const trackCenterControl = document.getElementById("trackCenterControl");
      const trackCenterToggle = document.getElementById("trackCenterToggle");

      const sandbox = new GlslCanvas(canvas);
      const paramSandbox = new GlslCanvas(paramCanvas);

      // -------------------
      // Conditional instructions
      // -------------------
      const baseText = `
        <p>
          This visualization renders the <strong>Newton fractal</strong> for a cubic polynomial with three roots (marked as two black dots and one gray dot that you can control the position of).
          Each pixel represents a starting point on the complex plane. We apply Newton's method to these points to find one of the polynomial's roots.
          The pixel's color indicates which root the method converges to: red, green, and blue correspond to the three roots.
          Intermediate or dark colors appear where points take longer to converge or fail to converge entirely.
          With enough iterations, the plane divides into three <strong>basins of attraction</strong>.
          While the interiors of these basins are smooth, the boundaries are fractals: complex, chaotic regions where the smallest shift in starting position can lead to a completely different outcome.
        </p>
        <p>
          <em>Mathematical Insight:</em> While Newton's method is efficient, it is not foolproof. It can get trapped in an <strong>attracting cycle</strong>, where the value oscillates endlessly without ever reaching a root.
          For cubic polynomials, the <strong>centroid</strong> of the roots acts as a "canary in the coal mine". If an attracting cycle exists, the centroid is mathematically guaranteed to be pulled into it.
          The <strong>Parameter Space</strong> visualization (right) uses this fact. Here, each pixel represents a possible position for the third root (the movable gray dot).
          The color shows the fate of the centroid for that specific configuration. By exploring this space, you can find the "problematic" polynomials where Newton's method fails.
        </p>
      `;

      const desktopInstructions = `
      <p>
        <strong>Controls (Desktop):</strong><br>
        • <strong>Navigate:</strong> Right-click to toggle between <em>Move Mode</em> and <em>Pan/Zoom Mode</em>.<br>
        &nbsp;&nbsp;- <em>Pan/Zoom Mode:</em> Click & drag to pan, scroll to zoom.<br>
        &nbsp;&nbsp;- <em>Move Mode:</em> Move your mouse to position the third root (gray dot) or the path origin.<br>
        • <strong>Visualization:</strong> Use the slider to adjust the number of iterations.<br>
        • <strong>Analysis:</strong><br>
        &nbsp;&nbsp;- <em>Show Path:</em> Visualizes the individual steps of Newton's method for a single point (white dot).<br>
        &nbsp;&nbsp;- <em>Track Center:</em> Locks the path's starting point to the centroid of the roots (critical for analyzing cycles).<br>
        • <strong>Fullscreen:</strong> Available for both views.
      </p>
      `;

      const mobileInstructions = `
      <p>
        <strong>Controls (Mobile):</strong><br>
        • <strong>Move Root/Point:</strong> Drag the gray or white dots with one finger. (Double-tap and drag anywhere if precise selection is difficult).<br>
        • <strong>Navigate:</strong> Pan with two fingers, pinch to zoom.<br>
        • <strong>Analysis:</strong> Use the toggles to show the iteration path or track the centroid.<br>
        • <strong>Fullscreen:</strong> Tap the button for an immersive view.
      </p>
      `;

      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      descriptionEl.innerHTML = baseText + (isMobile ? mobileInstructions : desktopInstructions);

      // -------------------
      // State
      // -------------------
      let interactionMode = isMobile ? "root" : "pan";
      canvas.style.cursor = isMobile ? "crosshair" : "move";
      let zoom = 1.0;
      let pan = [0.0, 0.0];
      let rootPosition = [0.0, 0.866025];
      // NEW STATE
      let showPath = false;
      let controlPathOrigin = false;
      let trackCenter = false;
      let pathOrigin = [0.5, 0.5]; // Default path start

      let isDragging = false;
      let lastMousePos = { x: 0, y: 0 };
      let ongoingTouches = [];
      let touchMode = null;
      let touchStartPos = null;

      function getShaderMouse(event, targetCanvas) {
        const rect = targetCanvas.getBoundingClientRect();
        const x_css = event.clientX - rect.left;
        const y_css = event.clientY - rect.top;
        const small_resol = Math.min(rect.width, rect.height);
        const uv_x = (2.0 * x_css - rect.width) / small_resol;
        const uv_y = (2.0 * (rect.height - y_css) - rect.height) / small_resol;
        return [(uv_x * zoom) + pan[0], (uv_y * zoom) + pan[1]];
      }

      function getTouchPos(touch, targetCanvas) {
        const rect = targetCanvas.getBoundingClientRect();
        const x_css = touch.clientX - rect.left;
        const y_css = touch.clientY - rect.top;
        const small_resol = Math.min(rect.width, rect.height);
        const uv_x = (2.0 * x_css - rect.width) / small_resol;
        const uv_y = (2.0 * (rect.height - y_css) - rect.height) / small_resol;
        return [(uv_x * zoom) + pan[0], (uv_y * zoom) + pan[1]];
      }

      function resizeToCurrentDisplay() {
        const cssWidth = canvas.clientWidth;
        const cssHeight = canvas.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
        sandbox.resize();

        // Resize param canvas
        const cssWidth2 = paramCanvas.clientWidth;
        const cssHeight2 = paramCanvas.clientHeight;
        paramCanvas.width = Math.round(cssWidth2 * dpr);
        paramCanvas.height = Math.round(cssHeight2 * dpr);
        paramCanvas.width = Math.round(cssWidth2 * dpr);
        paramCanvas.height = Math.round(cssHeight2 * dpr);
        paramSandbox.resize();

        // Calculate screen ratio
        const screenMin = Math.min(window.screen.width, window.screen.height) * dpr;
        const canvasMin = Math.min(canvas.width, canvas.height);
        const screenRatio = canvasMin / screenMin;

        sandbox.setUniform("u_screen_ratio", screenRatio);
        paramSandbox.setUniform("u_screen_ratio", screenRatio);
      }

      function handleResize() { resizeToCurrentDisplay(); }

      // -------------------
      // Load both shaders
      // -------------------
      const fragUrl = new URL(canvas.getAttribute("data-fragment-url"), window.location.href);
      const paramFragUrl = new URL(paramCanvas.getAttribute("data-fragment-url"), window.location.href);

      try {
        // Load main shader
        const response = await fetch(fragUrl, { mode: "same-origin" });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const fragShader = await response.text();
        sandbox.load(fragShader);

        // Load parameter space shader
        const paramResponse = await fetch(paramFragUrl, { mode: "same-origin" });
        if (!paramResponse.ok) throw new Error(`HTTP ${paramResponse.status}`);
        const paramFragShader = await paramResponse.text();
        paramSandbox.load(paramFragShader);

        // ---- FIX: robust 2-frame initialization for BOTH shaders ----
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            resizeToCurrentDisplay();  // ensure correct framebuffer size for both canvases

            // Initialize main sandbox
            sandbox.setUniform("u_iterations", parseInt(slider.value, 10));
            sandbox.setUniform("u_zoom", zoom);
            sandbox.setUniform("u_pan", pan[0], pan[1]);
            sandbox.setUniform("u_root_position", rootPosition[0], rootPosition[1]);
            sandbox.setUniform("u_show_path", showPath ? 1.0 : 0.0);
            sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);

            // Initialize param sandbox
            paramSandbox.setUniform("u_iterations", parseInt(slider.value, 10));
            paramSandbox.setUniform("u_zoom", zoom);
            paramSandbox.setUniform("u_pan", pan[0], pan[1]);
            paramSandbox.setUniform("u_current_root2", rootPosition[0], rootPosition[1]);

            // Set screen ratio for both
            const dpr = window.devicePixelRatio || 1;
            const screenMin = Math.min(window.screen.width, window.screen.height) * dpr;
            const canvasMin = Math.min(canvas.width, canvas.height);
            const screenRatio = canvasMin / screenMin;
            sandbox.setUniform("u_screen_ratio", screenRatio);
            paramSandbox.setUniform("u_screen_ratio", screenRatio);

            // Force render both
            if (sandbox.forceRender) sandbox.forceRender();
            if (paramSandbox.forceRender) paramSandbox.forceRender();
          });
        });

      } catch (err) {
        console.error("Failed to load shaders:", err);
        const ctx = canvas.getContext("2d");
        ctx.fillText("Error loading shader", 20, 20);
        return;
      }

      iterDisplay.textContent = slider.value;

      slider.addEventListener("input", () => {
        const iterations = parseInt(slider.value, 10);
        sandbox.setUniform("u_iterations", iterations);
        paramSandbox.setUniform("u_iterations", iterations);
        iterDisplay.textContent = iterations;
      });

      // -------------------
      // NEW TOGGLE LISTENERS
      // -------------------
      showPathToggle.addEventListener("change", () => {
        showPath = showPathToggle.checked;
        sandbox.setUniform("u_show_path", showPath ? 1.0 : 0.0);

        if (showPath) {
          pathOriginControl.style.display = "inline"; // Show the second toggle
          trackCenterControl.style.display = "inline"; // Show the third toggle
        } else {
          pathOriginControl.style.display = "none"; // Hide it
          trackCenterControl.style.display = "none"; // Hide it
          // Also uncheck and reset the controlPathOrigin state
          if (controlPathOrigin) {
            controlPathOrigin = false;
            pathOriginToggle.checked = false;
          }
          // Reset trackCenter state
          if (trackCenter) {
            trackCenter = false;
            trackCenterToggle.checked = false;
            pathOriginToggle.disabled = false;
          }
        }
      });

      pathOriginToggle.addEventListener("change", () => {
        controlPathOrigin = pathOriginToggle.checked;
        // No uniform change, just state
      });

      trackCenterToggle.addEventListener("change", () => {
        trackCenter = trackCenterToggle.checked;
        if (trackCenter) {
          // Disable manual control
          controlPathOrigin = false;
          pathOriginToggle.checked = false;
          pathOriginToggle.disabled = true;

          // Snap to center immediately
          pathOrigin = [rootPosition[0] / 3.0, rootPosition[1] / 3.0];
          sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);
        } else {
          // Re-enable manual control option
          pathOriginToggle.disabled = false;
        }
      });

      // -------------------
      // Desktop interactions
      // -------------------
      function handleContextMenu(e) {
        e.preventDefault();
        if (interactionMode === 'root') {
          interactionMode = 'pan';
          canvas.style.cursor = 'move';
          paramCanvas.style.cursor = 'move';
        } else {
          interactionMode = 'root';
          canvas.style.cursor = 'crosshair';
          paramCanvas.style.cursor = 'crosshair';
        }
      }
      canvas.addEventListener("contextmenu", handleContextMenu);
      paramCanvas.addEventListener("contextmenu", handleContextMenu);

      function handleMouseDown(e) {
        if (interactionMode === 'pan' && e.button === 0) {
          isDragging = true;
          lastMousePos = { x: e.clientX, y: e.clientY };
        }
      }
      canvas.addEventListener("mousedown", handleMouseDown);
      paramCanvas.addEventListener("mousedown", handleMouseDown);

      window.addEventListener("mouseup", (e) => { if (e.button === 0) isDragging = false; });

      function handleMouseMove(e) {
        const targetCanvas = e.target;
        // Only process if target is one of our canvases
        if (targetCanvas !== canvas && targetCanvas !== paramCanvas) return;

        const [shaderX, shaderY] = getShaderMouse(e, targetCanvas);
        if (isDragging && interactionMode === 'pan') {
          const deltaX_css = e.clientX - lastMousePos.x;
          const deltaY_css = e.clientY - lastMousePos.y;
          const rect = targetCanvas.getBoundingClientRect();
          const small_resol = Math.min(targetCanvas.width, targetCanvas.height);
          const deltaX_shader = (deltaX_css * (targetCanvas.width / rect.width) * 2.0 / small_resol) * zoom;
          const deltaY_shader = (deltaY_css * (targetCanvas.height / rect.height) * 2.0 / small_resol) * zoom;
          pan[0] -= deltaX_shader;
          pan[1] += deltaY_shader;
          sandbox.setUniform("u_pan", pan[0], pan[1]);
          paramSandbox.setUniform("u_pan", pan[0], pan[1]);
          lastMousePos = { x: e.clientX, y: e.clientY };
        } else if (interactionMode === 'root') {
          // MODIFIED LOGIC
          if (showPath && controlPathOrigin) {
            pathOrigin = [shaderX, shaderY];
            sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);
          } else {
            rootPosition = [shaderX, shaderY];
            sandbox.setUniform("u_root_position", shaderX, shaderY);
            paramSandbox.setUniform("u_current_root2", shaderX, shaderY);

            // Update path origin if tracking
            if (trackCenter) {
              pathOrigin = [rootPosition[0] / 3.0, rootPosition[1] / 3.0];
              sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);
            }
          }
        }
      }
      canvas.addEventListener("mousemove", handleMouseMove);
      paramCanvas.addEventListener("mousemove", handleMouseMove);

      function handleWheel(e) {
        e.preventDefault();
        const targetCanvas = e.target;
        if (interactionMode === 'pan') {
          const [mouseX_before, mouseY_before] = getShaderMouse(e, targetCanvas);
          const zoomAmount = e.deltaY * 0.0005;
          zoom *= (1.0 + zoomAmount);
          sandbox.setUniform("u_zoom", zoom);
          paramSandbox.setUniform("u_zoom", zoom);

          const [mouseX_after, mouseY_after] = getShaderMouse(e, targetCanvas);
          pan[0] += (mouseX_before - mouseX_after);
          pan[1] += (mouseY_before - mouseY_after);
          sandbox.setUniform("u_pan", pan[0], pan[1]);
          paramSandbox.setUniform("u_pan", pan[0], pan[1]);
        }
      }
      canvas.addEventListener("wheel", handleWheel);
      paramCanvas.addEventListener("wheel", handleWheel);

      // -------------------
      // Mobile interactions (updated)
      // -------------------
      let lastTapTime = 0;
      const doubleTapThreshold = 300; // ms
      const rootTouchRadius = 0.1; // proximity threshold in shader coordinates

      function distance2D(a, b) {
        return Math.hypot(a[0] - b[0], a[1] - b[1]);
      }

      function handleTouchStart(e) {
        e.preventDefault();
        ongoingTouches = [...e.touches];
        const targetCanvas = e.target;

        if (ongoingTouches.length === 1) {
          const [x, y] = getTouchPos(ongoingTouches[0], targetCanvas);
          const now = Date.now();
          const timeSinceLastTap = now - lastTapTime;

          const dynamicRadius = rootTouchRadius * zoom; // scale with zoom

          // Check proximity to both, path origin takes priority
          const distToRoot = distance2D([x, y], rootPosition);
          const distToPath = showPath ? distance2D([x, y], pathOrigin) : Infinity; // Only check path if shown

          if (timeSinceLastTap < doubleTapThreshold) {
            // Double-tap-drag: behavior depends on 'controlPathOrigin' toggle
            if (showPath && controlPathOrigin) {
              touchMode = 'movePathOrigin';
            } else {
              touchMode = 'moveRoot';
            }
          } else {
            // Single-tap-drag: behavior depends on proximity, path origin takes priority
            if (showPath && distToPath < dynamicRadius) {
              touchMode = 'movePathOrigin';
            } else if (distToRoot < dynamicRadius) {
              touchMode = 'moveRoot';
            } else {
              touchMode = null;
            }
          }

          touchStartPos = { x: ongoingTouches[0].clientX, y: ongoingTouches[0].clientY };
          lastTapTime = now;
        } else if (ongoingTouches.length === 2) {
          touchMode = 'pan';
        }
      }
      canvas.addEventListener("touchstart", handleTouchStart);
      paramCanvas.addEventListener("touchstart", handleTouchStart);

      function handleTouchMove(e) {
        e.preventDefault();
        const targetCanvas = e.target;
        if (e.touches.length === 2) touchMode = 'pan';

        if (touchMode === 'movePathOrigin' && e.touches.length === 1) {
          const [x, y] = getTouchPos(e.touches[0], targetCanvas);
          pathOrigin = [x, y];
          sandbox.setUniform("u_path_origin", x, y);
        } else if (touchMode === 'moveRoot' && e.touches.length === 1) {
          const [x, y] = getTouchPos(e.touches[0], targetCanvas);
          rootPosition = [x, y];
          sandbox.setUniform("u_root_position", x, y);
          paramSandbox.setUniform("u_current_root2", x, y);

          // Update path origin if tracking
          if (trackCenter) {
            pathOrigin = [rootPosition[0] / 3.0, rootPosition[1] / 3.0];
            sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);
          }
        } else if (touchMode === 'pan' && e.touches.length === 2) {
          const t0 = e.touches[0];
          const t1 = e.touches[1];
          const prevT0 = ongoingTouches[0];
          const prevT1 = ongoingTouches[1];

          const prevDist = Math.hypot(prevT0.clientX - prevT1.clientX, prevT0.clientY - prevT1.clientY);
          const newDist = Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
          // avoid division by zero
          if (prevDist > 0 && newDist > 0) {
            const zoomFactor = prevDist / newDist;
            zoom *= zoomFactor;
          }

          const prevMidX = (prevT0.clientX + prevT1.clientX) / 2;
          const prevMidY = (prevT0.clientY + prevT1.clientY) / 2;
          const newMidX = (t0.clientX + t1.clientX) / 2;
          const newMidY = (t0.clientY + t1.clientY) / 2;

          const rect = targetCanvas.getBoundingClientRect();
          const small_resol = Math.min(rect.width, rect.height);
          const deltaX_shader = ((newMidX - prevMidX) * 2.0 / small_resol) * zoom;
          const deltaY_shader = ((newMidY - prevMidY) * 2.0 / small_resol) * zoom;

          pan[0] -= deltaX_shader;
          pan[1] += deltaY_shader;

          sandbox.setUniform("u_zoom", zoom);
          sandbox.setUniform("u_pan", pan[0], pan[1]);
          paramSandbox.setUniform("u_zoom", zoom);
          paramSandbox.setUniform("u_pan", pan[0], pan[1]);
        }

        ongoingTouches = [...e.touches];
      }
      canvas.addEventListener("touchmove", handleTouchMove);
      paramCanvas.addEventListener("touchmove", handleTouchMove);

      // -------------------
      // Fullscreen
      // -------------------
      function reapplyState() {
        sandbox.setUniform("u_iterations", parseInt(slider.value, 10));
        sandbox.setUniform("u_zoom", zoom);
        sandbox.setUniform("u_pan", pan[0], pan[1]);
        sandbox.setUniform("u_root_position", rootPosition[0], rootPosition[1]);
        // NEW UNIFORMS
        sandbox.setUniform("u_show_path", showPath ? 1.0 : 0.0);
        sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);
        sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);

        paramSandbox.setUniform("u_iterations", parseInt(slider.value, 10));
        paramSandbox.setUniform("u_zoom", zoom);
        paramSandbox.setUniform("u_pan", pan[0], pan[1]);
        paramSandbox.setUniform("u_current_root2", rootPosition[0], rootPosition[1]);

        // Update screen ratio
        const dpr = window.devicePixelRatio || 1;
        const screenMin = Math.min(window.screen.width, window.screen.height) * dpr;
        const canvasMin = Math.min(canvas.width, canvas.height);
        const screenRatio = canvasMin / screenMin;
        sandbox.setUniform("u_screen_ratio", screenRatio);
        paramSandbox.setUniform("u_screen_ratio", screenRatio);

        requestAnimationFrame(() => {
          if (sandbox.forceRender) sandbox.forceRender();
          if (paramSandbox.forceRender) paramSandbox.forceRender();
        });
      }

      async function toggleFullscreen(targetWrapper) {
        if (!document.fullscreenElement) {
          try {
            await targetWrapper.requestFullscreen();
          } catch (err) {
            console.error("Error attempting to enable fullscreen:", err);
          }
        } else {
          await document.exitFullscreen();
        }
      }

      fullscreenBtnMain.addEventListener("click", () => toggleFullscreen(wrapperMain));
      fullscreenBtnParam.addEventListener("click", () => toggleFullscreen(wrapperParam));

      document.addEventListener("fullscreenchange", () => {
        const isFullscreen = !!document.fullscreenElement;
        fullscreenBtnMain.textContent = "Fullscreen";
        fullscreenBtnParam.textContent = "Fullscreen";

        if (isFullscreen) {
          if (document.fullscreenElement === wrapperMain) {
            fullscreenBtnMain.textContent = "Exit Fullscreen";
          } else if (document.fullscreenElement === wrapperParam) {
            fullscreenBtnParam.textContent = "Exit Fullscreen";
          }
        }
        setTimeout(() => { resizeToCurrentDisplay(); reapplyState(); }, 150);
      });

      window.addEventListener("resize", handleResize);

      // -------------------
      // Fix for mobile blank canvas
      // -------------------
      function ensureCanvasRenders() {
        if (sandbox.forceRender) sandbox.forceRender();
        if (paramSandbox.forceRender) paramSandbox.forceRender();
      }

    });
  </script>
</body>

</html>