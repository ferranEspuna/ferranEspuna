---
layout: default
title: Newton's Fractal
---

<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

  <style>
    body {
      text-align: center;
      margin: 0;
      padding: 2em;
      overflow-y: auto;
      /* allow scrolling */
      overflow-x: hidden;
    }

    nav {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
    }

    .shader-window {
      max-width: 800px;
      margin: 0 auto;
    }

    canvas {
      display: block;
      width: 100%;
      aspect-ratio: 1/1;
      border-radius: 0.5em;
      cursor: crosshair;
      touch-action: none;
      /* needed for multi-touch */
    }

    .controls {
      margin-top: 1em;
    }

    .description {
      max-width: 800px;
      margin: 1em auto 2em auto;
      font-size: 0.95em;
      line-height: 1.5em;
      text-align: left;
    }

    .description code {
      padding: 0.15em 0.3em;
      border-radius: 0.25em;
    }

    button {
      padding: 0.4em 0.8em;
      border-radius: 0.3em;
      cursor: pointer;
      margin-top: 0.5em;
      font-size: 0.9em;
      transition: background 0.2s;
    }

    .canvas-wrapper {
      position: relative;
      width: 100%;
      /* aspect-ratio: 1/1; Remove this to let content dictate, or keep? Canvas has it. */
    }

    .canvas-wrapper:fullscreen {
      width: 100vw;
      height: 100vh;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .canvas-wrapper:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fullscreen-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 20;
      opacity: 0.7;
      background: rgba(255, 255, 255, 0.8);
      border: none;
      font-weight: bold;
    }

    .fullscreen-btn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 1);
    }

    canvas:fullscreen {
      /* Reset canvas fullscreen styles as we wrapper is now fullscreen */
      width: 100% !important;
      height: 100% !important;
      aspect-ratio: auto !important;
    }

    /* Also target the canvas when its parent wrapper is fullscreen */
    .canvas-wrapper:fullscreen canvas {
      width: 100% !important;
      height: 100% !important;
      aspect-ratio: auto !important;
      max-width: none !important;
      max-height: none !important;
    }

    .canvas-wrapper:-webkit-full-screen canvas {
      width: 100% !important;
      height: 100% !important;
      aspect-ratio: auto !important;
      max-width: none !important;
      max-height: none !important;
    }
  </style>
</head>

<body>

  <nav>
    <a href="../">&larr; About Me</a>
  </nav>

  <h1>Newton's Fractal</h1>

  <div class="description" id="description"></div>

  <div class="controls" style="margin-bottom: 1em;">
    <label for="iterSlider">Iterations:</label>
    <input type="range" id="iterSlider" min="0" max="100" value="10">
    <span id="iterValue">10</span>
  </div>

  <div class="shader-container" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;">
    <div class="shader-window" style="flex: 1; min-width: 300px;">
      <h3>Phase Space</h3>
      <div class="canvas-wrapper" id="wrapperMain">
        <button id="fullscreenBtnMain" class="fullscreen-btn">Fullscreen</button>
        <canvas class="glslCanvas" id="mainCanvas" data-fragment-url="shader.frag"></canvas>
      </div>
      <div class="controls"
        style="margin-top: 0.5em; display: flex; flex-wrap: wrap; gap: 0.2em 1em; justify-content: center;">
        <span style="white-space: nowrap;">
          <input type="checkbox" id="showPathToggle">
          <label for="showPathToggle">Show Path</label>
        </span>

        <span id="pathOriginControl" style="display: none; white-space: nowrap;">
          <input type="checkbox" id="pathOriginToggle">
          <label for="pathOriginToggle">Control Path Origin</label>
        </span>
        <span id="trackCenterControl" style="display: none; white-space: nowrap;">
          <input type="checkbox" id="trackCenterToggle">
          <label for="trackCenterToggle">Track Center</label>
        </span>
      </div>
    </div>
    <div class="shader-window" style="flex: 1; min-width: 300px;">
      <h3>Parameter Space</h3>
      <div class="canvas-wrapper" id="wrapperParam">
        <button id="fullscreenBtnParam" class="fullscreen-btn">Fullscreen</button>
        <button id="resetViewBtnParam" class="fullscreen-btn" style="right: auto; left: 10px;">Reset View</button>
        <canvas class="glslCanvas" id="paramCanvas" data-fragment-url="parameter_space.frag"></canvas>
      </div>
    </div>
  </div>



  <script type="module">
    import GlslCanvas from "https://esm.run/glslCanvas";

    window.addEventListener("load", async () => {
      const canvas = document.getElementById("mainCanvas");
      const paramCanvas = document.getElementById("paramCanvas");
      const wrapperMain = document.getElementById("wrapperMain");
      const wrapperParam = document.getElementById("wrapperParam");
      const slider = document.getElementById("iterSlider");
      const iterDisplay = document.getElementById("iterValue");
      const fullscreenBtnMain = document.getElementById("fullscreenBtnMain");
      const fullscreenBtnParam = document.getElementById("fullscreenBtnParam");
      const descriptionEl = document.getElementById("description");
      // NEW DOM ELEMENTS
      const showPathToggle = document.getElementById("showPathToggle");
      const pathOriginControl = document.getElementById("pathOriginControl");
      const pathOriginToggle = document.getElementById("pathOriginToggle");
      const trackCenterControl = document.getElementById("trackCenterControl");
      const trackCenterToggle = document.getElementById("trackCenterToggle");
      const resetViewBtnParam = document.getElementById("resetViewBtnParam");

      const sandbox = new GlslCanvas(canvas);
      const paramSandbox = new GlslCanvas(paramCanvas);

      // -------------------
      // Conditional instructions
      // -------------------
      const baseText = `
        <p>
          This visualization renders the <strong>Newton fractal</strong> for a cubic polynomial with three roots (marked as two black dots and one gray dot that you can control the position of).
          Each pixel represents a starting point on the complex plane. We apply Newton's method to these points to find one of the polynomial's roots.
          The pixel's color indicates which root the method converges to: red, green, and blue correspond to the three roots.
          Intermediate or dark colors appear where points take longer to converge or fail to converge entirely.
          With enough iterations, the plane divides into three <strong>basins of attraction</strong>.
          While the interiors of these basins are smooth, the boundaries are fractals: complex, chaotic regions where the smallest shift in starting position can lead to a completely different outcome.
        </p>
        <p>
          <em>Mathematical Insight:</em> While Newton's method is efficient, it is not foolproof. It can get trapped in an <strong>attracting cycle</strong>, where the value oscillates endlessly without ever reaching a root.
          For cubic polynomials, the <strong>centroid</strong> of the roots acts as a "canary in the coal mine". If an attracting cycle exists, the centroid is mathematically guaranteed to be pulled into it.
          The <strong>Parameter Space</strong> visualization (right) uses this fact. Here, each pixel represents a possible position for the third root (the movable gray dot).
          The color shows the fate of the centroid for that specific configuration. By exploring this space, you can find the "problematic" polynomials where Newton's method fails,
          represented as dark or intermediate-colored regions. Can you find any familiar patterns in these regions? What lengths of attracting cycles can you find?
        </p>
      `;

      const desktopInstructions = `
      <p>
        <strong>Controls (Desktop):</strong><br>
        • <strong>Navigate:</strong> Right-click <em>on a specific canvas</em> to toggle its mode between <em>Move Mode</em> and <em>Pan/Zoom Mode</em>.<br>
        &nbsp;&nbsp;- <em>Pan/Zoom Mode:</em> Click & drag to pan, scroll to zoom.<br>
        &nbsp;&nbsp;- <em>Move Mode:</em> Move your mouse to position the third root (gray dot) or the path origin.<br>
        • <strong>Iterations:</strong> Use the slider above to adjust the number of iterations.<br>
        • <strong>Analysis:</strong> Controls below the Phase Space plot:<br>
        &nbsp;&nbsp;- <em>Show Path:</em> Visualizes the individual steps of Newton's method for a single point (white dot).<br>
        &nbsp;&nbsp;- <em>Track Center:</em> Locks the path's starting point to the centroid of the roots.<br>
        • <strong>Sync:</strong> Use the "Reset View" button on the Parameter Space to match the Phase Space view.<br>
        • <strong>Fullscreen:</strong> Available for both views.
      </p>
      `;

      const mobileInstructions = `
      <p>
        <strong>Controls (Mobile):</strong><br>
        • <strong>Move Root/Point:</strong> Drag the gray or white dots with one finger. (Double-tap and drag anywhere if precise selection is difficult).<br>
        • <strong>Navigate:</strong> Pan with two fingers, pinch to zoom.<br>
        • <strong>Analysis:</strong> Use the toggles to show the iteration path or track the centroid.<br>
        • <strong>Fullscreen:</strong> Tap the button for an immersive view.
      </p>
      `;

      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      descriptionEl.innerHTML = baseText + (isMobile ? mobileInstructions : desktopInstructions);

      // -------------------
      // State
      // -------------------
      let interactionModeMain = isMobile ? "root" : "pan";
      let interactionModeParam = isMobile ? "root" : "pan";

      canvas.style.cursor = isMobile ? "crosshair" : "move";
      paramCanvas.style.cursor = isMobile ? "crosshair" : "move";

      // Independent state for Main Canvas
      let zoomMain = 1.0;
      let panMain = [0.0, 0.0];

      // Independent state for Parameter Canvas
      let zoomParam = 1.0;
      let panParam = [0.0, 0.0];

      let rootPosition = [0.0, 0.866025];
      // NEW STATE
      let showPath = false;
      let controlPathOrigin = false;
      let trackCenter = false;
      let pathOrigin = [0.5, 0.5]; // Default path start

      let isDragging = false;
      let lastMousePos = { x: 0, y: 0 };
      let ongoingTouches = [];
      let touchMode = null;
      let touchStartPos = null;

      // Animation State
      let animationFrameId = null;

      function cancelAnimation() {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
      }

      function getShaderMouse(event, targetCanvas) {
        const rect = targetCanvas.getBoundingClientRect();
        const x_css = event.clientX - rect.left;
        const y_css = event.clientY - rect.top;
        const small_resol = Math.min(rect.width, rect.height);
        const uv_x = (2.0 * x_css - rect.width) / small_resol;
        const uv_y = (2.0 * (rect.height - y_css) - rect.height) / small_resol;

        const isMain = targetCanvas === canvas;
        const z = isMain ? zoomMain : zoomParam;
        const p = isMain ? panMain : panParam;

        return [(uv_x * z) + p[0], (uv_y * z) + p[1]];
      }

      function getTouchPos(touch, targetCanvas) {
        const rect = targetCanvas.getBoundingClientRect();
        const x_css = touch.clientX - rect.left;
        const y_css = touch.clientY - rect.top;
        const small_resol = Math.min(rect.width, rect.height);
        const uv_x = (2.0 * x_css - rect.width) / small_resol;
        const uv_y = (2.0 * (rect.height - y_css) - rect.height) / small_resol;

        const isMain = targetCanvas === canvas;
        const z = isMain ? zoomMain : zoomParam;
        const p = isMain ? panMain : panParam;

        return [(uv_x * z) + p[0], (uv_y * z) + p[1]];
      }

      function resizeToCurrentDisplay() {
        const cssWidth = canvas.clientWidth;
        const cssHeight = canvas.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
        sandbox.resize();

        // Resize param canvas
        const cssWidth2 = paramCanvas.clientWidth;
        const cssHeight2 = paramCanvas.clientHeight;
        paramCanvas.width = Math.round(cssWidth2 * dpr);
        paramCanvas.height = Math.round(cssHeight2 * dpr);
        paramCanvas.width = Math.round(cssWidth2 * dpr);
        paramCanvas.height = Math.round(cssHeight2 * dpr);
        paramSandbox.resize();

        // Calculate screen ratio
        const screenMin = Math.min(window.screen.width, window.screen.height) * dpr;
        const canvasMin = Math.min(canvas.width, canvas.height);
        const screenRatio = canvasMin / screenMin;

        sandbox.setUniform("u_screen_ratio", screenRatio);

        const paramCanvasMin = Math.min(paramCanvas.width, paramCanvas.height);
        const paramScreenRatio = paramCanvasMin / screenMin;
        paramSandbox.setUniform("u_screen_ratio", paramScreenRatio);
      }

      function handleResize() { resizeToCurrentDisplay(); }

      // -------------------
      // Load both shaders
      // -------------------
      const fragUrl = new URL(canvas.getAttribute("data-fragment-url"), window.location.href);
      const paramFragUrl = new URL(paramCanvas.getAttribute("data-fragment-url"), window.location.href);

      try {
        // Load main shader
        const response = await fetch(fragUrl, { mode: "same-origin" });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const fragShader = await response.text();
        sandbox.load(fragShader);

        // Load parameter space shader
        const paramResponse = await fetch(paramFragUrl, { mode: "same-origin" });
        if (!paramResponse.ok) throw new Error(`HTTP ${paramResponse.status}`);
        const paramFragShader = await paramResponse.text();
        paramSandbox.load(paramFragShader);

        // ---- FIX: robust 2-frame initialization for BOTH shaders ----
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            resizeToCurrentDisplay();  // ensure correct framebuffer size for both canvases

            // Initialize main sandbox
            sandbox.setUniform("u_iterations", parseInt(slider.value, 10));
            sandbox.setUniform("u_zoom", zoomMain);
            sandbox.setUniform("u_pan", panMain[0], panMain[1]);
            sandbox.setUniform("u_root_position", rootPosition[0], rootPosition[1]);
            sandbox.setUniform("u_show_path", showPath ? 1.0 : 0.0);
            sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);

            // Initialize param sandbox
            paramSandbox.setUniform("u_iterations", parseInt(slider.value, 10));
            paramSandbox.setUniform("u_zoom", zoomParam);
            paramSandbox.setUniform("u_pan", panParam[0], panParam[1]);
            paramSandbox.setUniform("u_current_root2", rootPosition[0], rootPosition[1]);

            // Set screen ratio for both
            const dpr = window.devicePixelRatio || 1;
            const screenMin = Math.min(window.screen.width, window.screen.height) * dpr;
            const canvasMin = Math.min(canvas.width, canvas.height);
            const screenRatio = canvasMin / screenMin;
            sandbox.setUniform("u_screen_ratio", screenRatio);

            const paramCanvasMin = Math.min(paramCanvas.width, paramCanvas.height);
            const paramScreenRatio = paramCanvasMin / screenMin;
            paramSandbox.setUniform("u_screen_ratio", paramScreenRatio);

            // Force render both
            if (sandbox.render) sandbox.render();
            if (paramSandbox.render) paramSandbox.render();
          });
        });

      } catch (err) {
        console.error("Failed to load shaders:", err);
        const ctx = canvas.getContext("2d");
        ctx.fillText("Error loading shader", 20, 20);
        return;
      }

      iterDisplay.textContent = slider.value;

      slider.addEventListener("input", () => {
        const iterations = parseInt(slider.value, 10);
        sandbox.setUniform("u_iterations", iterations);
        paramSandbox.setUniform("u_iterations", iterations);
        iterDisplay.textContent = iterations;
      });

      // -------------------
      // NEW TOGGLE LISTENERS
      // -------------------
      showPathToggle.addEventListener("change", () => {
        showPath = showPathToggle.checked;
        sandbox.setUniform("u_show_path", showPath ? 1.0 : 0.0);

        if (showPath) {
          pathOriginControl.style.display = "inline"; // Show the second toggle
          trackCenterControl.style.display = "inline"; // Show the third toggle
        } else {
          pathOriginControl.style.display = "none"; // Hide it
          trackCenterControl.style.display = "none"; // Hide it
          // Also uncheck and reset the controlPathOrigin state
          if (controlPathOrigin) {
            controlPathOrigin = false;
            pathOriginToggle.checked = false;
          }
          // Reset trackCenter state
          if (trackCenter) {
            trackCenter = false;
            trackCenterToggle.checked = false;
            pathOriginToggle.disabled = false;
          }
        }
      });

      pathOriginToggle.addEventListener("change", () => {
        controlPathOrigin = pathOriginToggle.checked;
        // No uniform change, just state
      });

      trackCenterToggle.addEventListener("change", () => {
        trackCenter = trackCenterToggle.checked;
        if (trackCenter) {
          // Disable manual control
          controlPathOrigin = false;
          pathOriginToggle.checked = false;
          pathOriginToggle.disabled = true;

          // Snap to center immediately
          pathOrigin = [rootPosition[0] / 3.0, rootPosition[1] / 3.0];
          sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);
        } else {
          // Re-enable manual control option
          pathOriginToggle.disabled = false;
        }
      });

      // -------------------
      // Reset View Logic
      // -------------------
      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      function animateReset(targetZoom, targetPan) {
        cancelAnimation();

        const startZoom = zoomParam;
        const startPan = [...panParam];
        const startTime = performance.now();
        const duration = 500; // ms

        function step(now) {
          const elapsed = now - startTime;
          const progress = Math.min(elapsed / duration, 1.0);
          const t = easeInOutCubic(progress);

          // Interpolate Pan (Linear)
          panParam[0] = startPan[0] + (targetPan[0] - startPan[0]) * t;
          panParam[1] = startPan[1] + (targetPan[1] - startPan[1]) * t;

          // Interpolate Zoom (Logarithmic for natural feel)
          // log(z) = log(start) + t * (log(target) - log(start))
          // z = exp(log(start) + ...)
          const logStart = Math.log(startZoom);
          const logTarget = Math.log(targetZoom);
          zoomParam = Math.exp(logStart + (logTarget - logStart) * t);

          paramSandbox.setUniform("u_zoom", zoomParam);
          paramSandbox.setUniform("u_pan", panParam[0], panParam[1]);
          paramSandbox.setUniform("u_zoom", zoomParam);
          paramSandbox.setUniform("u_pan", panParam[0], panParam[1]);
          if (paramSandbox.render) paramSandbox.render();

          if (progress < 1.0) {
            animationFrameId = requestAnimationFrame(step);
          } else {
            animationFrameId = null;
          }
        }

        animationFrameId = requestAnimationFrame(step);
      }

      resetViewBtnParam.addEventListener("click", () => {
        animateReset(zoomMain, panMain);
      });

      // -------------------
      // Desktop interactions
      // -------------------
      function handleContextMenu(e) {
        e.preventDefault();
        const targetCanvas = e.target;
        const isMain = targetCanvas === canvas;

        if (isMain) {
          if (interactionModeMain === 'root') {
            interactionModeMain = 'pan';
            canvas.style.cursor = 'move';
          } else {
            interactionModeMain = 'root';
            canvas.style.cursor = 'crosshair';
          }
        } else {
          if (interactionModeParam === 'root') {
            interactionModeParam = 'pan';
            paramCanvas.style.cursor = 'move';
          } else {
            interactionModeParam = 'root';
            paramCanvas.style.cursor = 'crosshair';
          }
        }
      }
      canvas.addEventListener("contextmenu", handleContextMenu);
      paramCanvas.addEventListener("contextmenu", handleContextMenu);

      function handleMouseDown(e) {
        cancelAnimation(); // User interaction stops animation
        const targetCanvas = e.target;
        const isMain = targetCanvas === canvas;
        const currentMode = isMain ? interactionModeMain : interactionModeParam;

        if (currentMode === 'pan' && e.button === 0) {
          isDragging = true;
          lastMousePos = { x: e.clientX, y: e.clientY };
        }
      }
      canvas.addEventListener("mousedown", handleMouseDown);
      paramCanvas.addEventListener("mousedown", handleMouseDown);

      window.addEventListener("mouseup", (e) => { if (e.button === 0) isDragging = false; });

      function handleMouseMove(e) {
        const targetCanvas = e.target;
        // Only process if target is one of our canvases
        if (targetCanvas !== canvas && targetCanvas !== paramCanvas) return;

        const isMain = targetCanvas === canvas;
        const [shaderX, shaderY] = getShaderMouse(e, targetCanvas);
        const currentMode = isMain ? interactionModeMain : interactionModeParam;

        if (isDragging && currentMode === 'pan') {
          const deltaX_css = e.clientX - lastMousePos.x;
          const deltaY_css = e.clientY - lastMousePos.y;
          const rect = targetCanvas.getBoundingClientRect();
          const small_resol = Math.min(targetCanvas.width, targetCanvas.height);

          const currentZoom = isMain ? zoomMain : zoomParam;
          const deltaX_shader = (deltaX_css * (targetCanvas.width / rect.width) * 2.0 / small_resol) * currentZoom;
          const deltaY_shader = (deltaY_css * (targetCanvas.height / rect.height) * 2.0 / small_resol) * currentZoom;

          if (isMain) {
            panMain[0] -= deltaX_shader;
            panMain[1] += deltaY_shader;
            sandbox.setUniform("u_pan", panMain[0], panMain[1]);
          } else {
            panParam[0] -= deltaX_shader;
            panParam[1] += deltaY_shader;
            paramSandbox.setUniform("u_pan", panParam[0], panParam[1]);
          }

          lastMousePos = { x: e.clientX, y: e.clientY };
        } else if (currentMode === 'root') {
          // MODIFIED LOGIC: Control Path Origin only applies to Main Canvas
          if (isMain && showPath && controlPathOrigin) {
            pathOrigin = [shaderX, shaderY];
            sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);
          } else {
            // Move root (applies to both canvases, but logic is same)
            rootPosition = [shaderX, shaderY];
            sandbox.setUniform("u_root_position", shaderX, shaderY);
            paramSandbox.setUniform("u_current_root2", shaderX, shaderY);

            // Update path origin if tracking
            if (trackCenter) {
              pathOrigin = [rootPosition[0] / 3.0, rootPosition[1] / 3.0];
              sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);
            }
          }
        }
      }
      canvas.addEventListener("mousemove", handleMouseMove);
      paramCanvas.addEventListener("mousemove", handleMouseMove);

      function handleWheel(e) {
        e.preventDefault();
        cancelAnimation(); // User interaction stops animation
        const targetCanvas = e.target;
        const isMain = targetCanvas === canvas;
        const currentMode = isMain ? interactionModeMain : interactionModeParam;

        if (currentMode === 'pan') {
          const [mouseX_before, mouseY_before] = getShaderMouse(e, targetCanvas);
          const zoomAmount = e.deltaY * 0.0005;

          if (isMain) {
            zoomMain *= (1.0 + zoomAmount);
            sandbox.setUniform("u_zoom", zoomMain);
          } else {
            zoomParam *= (1.0 + zoomAmount);
            paramSandbox.setUniform("u_zoom", zoomParam);
          }

          const [mouseX_after, mouseY_after] = getShaderMouse(e, targetCanvas);

          if (isMain) {
            panMain[0] += (mouseX_before - mouseX_after);
            panMain[1] += (mouseY_before - mouseY_after);
            sandbox.setUniform("u_pan", panMain[0], panMain[1]);
          } else {
            panParam[0] += (mouseX_before - mouseX_after);
            panParam[1] += (mouseY_before - mouseY_after);
            paramSandbox.setUniform("u_pan", panParam[0], panParam[1]);
          }
        }
      }
      canvas.addEventListener("wheel", handleWheel);
      paramCanvas.addEventListener("wheel", handleWheel);

      // -------------------
      // Mobile interactions (updated)
      // -------------------
      let lastTapTime = 0;
      const doubleTapThreshold = 300; // ms
      const rootTouchRadius = 0.1; // proximity threshold in shader coordinates

      function distance2D(a, b) {
        return Math.hypot(a[0] - b[0], a[1] - b[1]);
      }

      function handleTouchStart(e) {
        e.preventDefault();
        cancelAnimation(); // User interaction stops animation
        ongoingTouches = [...e.touches];
        const targetCanvas = e.target;

        if (ongoingTouches.length === 1) {
          const [x, y] = getTouchPos(ongoingTouches[0], targetCanvas);
          const now = Date.now();
          const timeSinceLastTap = now - lastTapTime;

          const isMain = targetCanvas === canvas;
          const currentZoom = isMain ? zoomMain : zoomParam;
          const dynamicRadius = rootTouchRadius * currentZoom; // scale with zoom

          // Check proximity to both, path origin takes priority
          const distToRoot = distance2D([x, y], rootPosition);
          const distToPath = (showPath && isMain) ? distance2D([x, y], pathOrigin) : Infinity; // Only check path if shown AND on main canvas

          if (timeSinceLastTap < doubleTapThreshold) {
            // Double-tap-drag: behavior depends on 'controlPathOrigin' toggle
            if (isMain && showPath && controlPathOrigin) {
              touchMode = 'movePathOrigin';
            } else {
              touchMode = 'moveRoot';
            }
          } else {
            // Single-tap-drag: behavior depends on proximity, path origin takes priority
            if (showPath && distToPath < dynamicRadius) {
              touchMode = 'movePathOrigin';
            } else if (distToRoot < dynamicRadius) {
              touchMode = 'moveRoot';
            } else {
              touchMode = null;
            }
          }

          touchStartPos = { x: ongoingTouches[0].clientX, y: ongoingTouches[0].clientY };
          lastTapTime = now;
        } else if (ongoingTouches.length === 2) {
          touchMode = 'pan';
        }
      }
      canvas.addEventListener("touchstart", handleTouchStart);
      paramCanvas.addEventListener("touchstart", handleTouchStart);

      function handleTouchMove(e) {
        e.preventDefault();
        const targetCanvas = e.target;
        if (e.touches.length === 2) touchMode = 'pan';

        if (touchMode === 'movePathOrigin' && e.touches.length === 1) {
          const [x, y] = getTouchPos(e.touches[0], targetCanvas);
          pathOrigin = [x, y];
          sandbox.setUniform("u_path_origin", x, y);
        } else if (touchMode === 'moveRoot' && e.touches.length === 1) {
          const [x, y] = getTouchPos(e.touches[0], targetCanvas);
          rootPosition = [x, y];
          sandbox.setUniform("u_root_position", x, y);
          paramSandbox.setUniform("u_current_root2", x, y);

          // Update path origin if tracking
          if (trackCenter) {
            pathOrigin = [rootPosition[0] / 3.0, rootPosition[1] / 3.0];
            sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);
          }
        } else if (touchMode === 'pan' && e.touches.length === 2) {
          const t0 = e.touches[0];
          const t1 = e.touches[1];
          const prevT0 = ongoingTouches[0];
          const prevT1 = ongoingTouches[1];

          const prevDist = Math.hypot(prevT0.clientX - prevT1.clientX, prevT0.clientY - prevT1.clientY);
          const newDist = Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);

          const isMain = targetCanvas === canvas;

          // avoid division by zero
          if (prevDist > 0 && newDist > 0) {
            const zoomFactor = prevDist / newDist;
            if (isMain) {
              zoomMain *= zoomFactor;
            } else {
              zoomParam *= zoomFactor;
            }
          }

          const prevMidX = (prevT0.clientX + prevT1.clientX) / 2;
          const prevMidY = (prevT0.clientY + prevT1.clientY) / 2;
          const newMidX = (t0.clientX + t1.clientX) / 2;
          const newMidY = (t0.clientY + t1.clientY) / 2;

          const rect = targetCanvas.getBoundingClientRect();
          const small_resol = Math.min(rect.width, rect.height);
          const currentZoom = isMain ? zoomMain : zoomParam;

          const deltaX_shader = ((newMidX - prevMidX) * 2.0 / small_resol) * currentZoom;
          const deltaY_shader = ((newMidY - prevMidY) * 2.0 / small_resol) * currentZoom;

          if (isMain) {
            panMain[0] -= deltaX_shader;
            panMain[1] += deltaY_shader;
            sandbox.setUniform("u_zoom", zoomMain);
            sandbox.setUniform("u_pan", panMain[0], panMain[1]);
          } else {
            panParam[0] -= deltaX_shader;
            panParam[1] += deltaY_shader;
            paramSandbox.setUniform("u_zoom", zoomParam);
            paramSandbox.setUniform("u_pan", panParam[0], panParam[1]);
          }
        }

        ongoingTouches = [...e.touches];
      }
      canvas.addEventListener("touchmove", handleTouchMove);
      paramCanvas.addEventListener("touchmove", handleTouchMove);

      // -------------------
      // Fullscreen
      // -------------------
      function reapplyState() {
        sandbox.setUniform("u_iterations", parseInt(slider.value, 10));
        sandbox.setUniform("u_zoom", zoomMain);
        sandbox.setUniform("u_pan", panMain[0], panMain[1]);
        sandbox.setUniform("u_root_position", rootPosition[0], rootPosition[1]);
        // NEW UNIFORMS
        sandbox.setUniform("u_show_path", showPath ? 1.0 : 0.0);
        sandbox.setUniform("u_path_origin", pathOrigin[0], pathOrigin[1]);

        paramSandbox.setUniform("u_iterations", parseInt(slider.value, 10));
        paramSandbox.setUniform("u_zoom", zoomParam);
        paramSandbox.setUniform("u_pan", panParam[0], panParam[1]);
        paramSandbox.setUniform("u_current_root2", rootPosition[0], rootPosition[1]);

        // Update screen ratio
        const dpr = window.devicePixelRatio || 1;
        const screenMin = Math.min(window.screen.width, window.screen.height) * dpr;
        const canvasMin = Math.min(canvas.width, canvas.height);
        const screenRatio = canvasMin / screenMin;
        sandbox.setUniform("u_screen_ratio", screenRatio);

        const paramCanvasMin = Math.min(paramCanvas.width, paramCanvas.height);
        const paramScreenRatio = paramCanvasMin / screenMin;
        paramSandbox.setUniform("u_screen_ratio", paramScreenRatio);

        requestAnimationFrame(() => {
          if (sandbox.render) sandbox.render();
          if (paramSandbox.render) paramSandbox.render();
        });
      }

      async function toggleFullscreen(targetWrapper) {
        if (!document.fullscreenElement) {
          try {
            await targetWrapper.requestFullscreen();
          } catch (err) {
            console.error("Error attempting to enable fullscreen:", err);
          }
        } else {
          await document.exitFullscreen();
        }
      }

      fullscreenBtnMain.addEventListener("click", () => toggleFullscreen(wrapperMain));
      fullscreenBtnParam.addEventListener("click", () => toggleFullscreen(wrapperParam));

      document.addEventListener("fullscreenchange", () => {
        const isFullscreen = !!document.fullscreenElement;
        fullscreenBtnMain.textContent = "Fullscreen";
        fullscreenBtnParam.textContent = "Fullscreen";

        if (isFullscreen) {
          if (document.fullscreenElement === wrapperMain) {
            fullscreenBtnMain.textContent = "Exit Fullscreen";
          } else if (document.fullscreenElement === wrapperParam) {
            fullscreenBtnParam.textContent = "Exit Fullscreen";
          }
        }
        setTimeout(() => { resizeToCurrentDisplay(); reapplyState(); }, 150);
      });

      window.addEventListener("resize", handleResize);

      // -------------------
      // Fix for mobile blank canvas
      // -------------------
      function ensureCanvasRenders() {
        if (sandbox.render) sandbox.render();
        if (paramSandbox.render) paramSandbox.render();
      }

    });
  </script>
</body>

</html>