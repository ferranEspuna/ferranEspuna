---
layout: default
title: Newton's Fractal
---

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

  <style>
    body {
      text-align: center;
      margin: 0;
      padding: 2em;
      overflow-y: auto;
      overflow-x: hidden;
    }

    nav {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
    }
    
    .shader-window {
      max-width: 800px;
      margin: 0 auto;
    }

    canvas {
      display: block;
      width: 100%;
      aspect-ratio: 1/1;
      border-radius: 0.5em;
      cursor: crosshair;
      touch-action: none;
    }

    .controls {
      margin-top: 1em;
    }

    .description {
      max-width: 800px;
      margin: 1em auto 2em auto;
      font-size: 0.95em;
      line-height: 1.5em;
      text-align: left;
    }

    .description code {
      padding: 0.15em 0.3em;
      border-radius: 0.25em;
    }

    button {
      padding: 0.4em 0.8em;
      border-radius: 0.3em;
      cursor: pointer;
      margin-top: 0.5em;
      font-size: 0.9em;
      transition: background 0.2s;
    }

    canvas:fullscreen {
      width: 100vw !important;
      height: 100vh !important;
      border-radius: 0;
    }

    canvas:-webkit-full-screen {
      width: 100vw !important;
      height: 100vh !important;
      border-radius: 0;
    }
  </style>
</head>

<body>

  <nav>
    <a href="../index.html">&larr; About Me</a>
  </nav>

  <h1>Newton's Fractal</h1>

  <div class="description" id="description"></div>

  <div class="shader-window">
    <canvas class="glslCanvas" data-fragment-url="shader.frag"></canvas>
  </div>

  <div class="controls">
    <label for="iterSlider">Iterations:</label>
    <input type="range" id="iterSlider" min="0" max="50" value="10">
    <span id="iterValue">5</span>
    <br>
    <button id="fullscreenBtn">Fullscreen</button>
  </div>

  <script type="module">
    import GlslCanvas from "https://esm.run/glslCanvas";

    window.addEventListener("load", async () => {
      const canvas = document.querySelector(".glslCanvas");
      const slider = document.getElementById("iterSlider");
      const iterDisplay = document.getElementById("iterValue");
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      const descriptionEl = document.getElementById("description");
      const sandbox = new GlslCanvas(canvas);

      const baseText = `
        <p>
          This visualization shows the <strong>Newton fractal</strong> for a cubic polynomial with three roots, shown as black dots.  
          Each pixel represents an initial complex number that is iteratively updated using Newton’s method to find a root.  
          The color indicates which root the iteration converges to — red, green, and blue correspond to closeness to each of the three roots.  
          Intermediate colors appear where points end up close to more than one root, while very dark regions represent points far from all roots.  
          As the number of iterations increases, most points are drawn toward one of the three roots, dividing the plane into three <strong>basins of attraction</strong>.  
          These basins of attraction are typically disconnected, and the boundaries between them exhibit a highly chaotic, fractal behaviour.
        </p>
      `;

      const desktopInstructions = `
      <p>
        <strong>How to interact (desktop):</strong><br>
        • Two of the roots are fixed in place (black dots).<br>
        • <strong>Right-click</strong> on the image to toggle between <em>Panning Mode</em> and <em>Root Placement Mode</em>.<br>
        • <em>Panning mode:</em> <strong>Click & drag</strong> to pan the view, <strong>scroll</strong> to zoom around the mouse.<br>
        • <em>Root Placement Mode:</em> <strong>Move the mouse</strong> to move the third root (white dot).<br>
        • Use the <strong>Iterations</strong> slider to control the number of Newton iterations.<br>
        • Click <strong>Fullscreen</strong> to view the fractal in immersive mode.
      </p>
      `;

      const mobileInstructions = `
      <p>
        <strong>How to interact (mobile):</strong><br>
        • Two of the roots are fixed in place (black dots).<br>
        • <strong>Move the third root (white dot):</strong> Drag a single finger <em>on top of current third root</em> or <em>double-tap + drag</em> anywhere.<br>
        • <strong>Pan:</strong> Drag with two fingers.<br>
        • <strong>Zoom:</strong> Pinch with two fingers.<br>
        • Use the <strong>iterations</strong> slider to control the number of Newton iterations.<br>
        • Tap <strong>Fullscreen</strong> to view the fractal in immersive mode.
      </p>
      <p>
        <strong>Known issues on mobile:</strong><br>
        • The image may not initially render. Double Tap on the fractal to fix it.
      </p>
      `;

      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      descriptionEl.innerHTML = baseText + (isMobile ? mobileInstructions : desktopInstructions);

      // -------------------
      // State (defaults)
      // -------------------
      let interactionMode = isMobile ? 'root' : 'pan'; // start in pan mode on desktop
      canvas.style.cursor = isMobile ? 'crosshair' : 'move';

      let zoom = 1.0;
      let pan = [0.0, 0.0];
      let rootPosition = [0.0, 1.0]; // default at 0 + 1i
      let isDragging = false;
      let lastMousePos = { x: 0, y: 0 };
      let ongoingTouches = [];
      let touchMode = null;
      let touchStartPos = null;

      function getShaderMouse(event) {
        const rect = canvas.getBoundingClientRect();
        const x_css = event.clientX - rect.left;
        const y_css = event.clientY - rect.top;
        const small_resol = Math.min(rect.width, rect.height);
        const uv_x = (2.0 * x_css - rect.width) / small_resol;
        const uv_y = (2.0 * (rect.height - y_css) - rect.height) / small_resol; 
        return [(uv_x * zoom) + pan[0], (uv_y * zoom) + pan[1]];
      }

      function resizeToCurrentDisplay() {
        const cssWidth = canvas.clientWidth;
        const cssHeight = canvas.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
        sandbox.resize();
      }

      // -------------------
      // Load shader
      // -------------------
      const fragUrl = new URL(canvas.getAttribute("data-fragment-url"), window.location.href);
      try {
        const response = await fetch(fragUrl, { mode: "same-origin" });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const fragShader = await response.text();
        sandbox.load(fragShader);
        requestAnimationFrame(resizeToCurrentDisplay);
        sandbox.forceRender && sandbox.forceRender();
      } catch (err) {
        console.error("Failed to load shader:", err);
        canvas.getContext("2d").fillText("Error loading shader", 20, 20);
        return;
      }

      // Apply initial uniforms (includes default root)
      sandbox.setUniform("u_iterations", parseInt(slider.value, 10));
      sandbox.setUniform("u_zoom", zoom);
      sandbox.setUniform("u_pan", pan[0], pan[1]);
      sandbox.setUniform("u_root_position", rootPosition[0], rootPosition[1]);
      iterDisplay.textContent = slider.value;
      sandbox.forceRender && sandbox.forceRender();

      // -------------------
      // Desktop interactions
      // -------------------
      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault(); 
        if (interactionMode === 'root') {
          interactionMode = 'pan';
          canvas.style.cursor = 'move';
        } else {
          interactionMode = 'root';
          canvas.style.cursor = 'crosshair';
        }
      });

      // (rest of your interaction code remains unchanged)
    });
  </script>
</body>
</html>
