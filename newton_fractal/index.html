---
layout: default
title: Newton's Fractal
---

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

  <style>
    body {
      text-align: center;
      margin: 0;
      padding: 2em;
      overflow-y: auto; /* allow scrolling */
      overflow-x: hidden;
    }

    nav {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
    }
    
    .shader-window {
      max-width: 800px;
      margin: 0 auto;
    }

    canvas {
      display: block;
      width: 100%;
      aspect-ratio: 1/1;
      border-radius: 0.5em;
      cursor: crosshair;
      touch-action: none; /* needed for multi-touch */
    }

    .controls {
      margin-top: 1em;
    }

    .description {
      max-width: 800px;
      margin: 1em auto 2em auto;
      font-size: 0.95em;
      line-height: 1.5em;
      text-align: left;
    }

    .description code {
      padding: 0.15em 0.3em;
      border-radius: 0.25em;
    }

    button {
      padding: 0.4em 0.8em;
      border-radius: 0.3em;
      cursor: pointer;
      margin-top: 0.5em;
      font-size: 0.9em;
      transition: background 0.2s;
    }

    canvas:fullscreen {
      width: 100vw !important;
      height: 100vh !important;
      border-radius: 0;
    }

    canvas:-webkit-full-screen {
      width: 100vw !important;
      height: 100vh !important;
      border-radius: 0;
    }
  </style>
</head>

<body>

  <nav>
    <a href="../index.html">&larr; Back to ferran.info</a>
  </nav>

  <h1>Newton's Fractal</h1>

  <div class="description" id="description"></div>

  <div class="shader-window">
    <canvas class="glslCanvas" data-fragment-url="shader.frag"></canvas>
  </div>

  <div class="controls">
    <label for="iterSlider">Iterations:</label>
    <input type="range" id="iterSlider" min="0" max="50" value="10">
    <span id="iterValue">5</span>
    <br>
    <button id="fullscreenBtn">Fullscreen</button>
  </div>

  <script type="module">
    import GlslCanvas from "https://esm.run/glslCanvas";

    window.addEventListener("load", async () => {
      const canvas = document.querySelector(".glslCanvas");
      const slider = document.getElementById("iterSlider");
      const iterDisplay = document.getElementById("iterValue");
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      const descriptionEl = document.getElementById("description");
      const sandbox = new GlslCanvas(canvas);

      // -------------------
      // Conditional instructions
      // -------------------
      const baseText = `
        <p>
          This visualization shows the <strong>Newton fractal</strong> for a cubic polynomial with three roots, shown as black dots.  
          Each pixel represents an initial complex number that is iteratively updated using Newton’s method to find a root.  
          The color indicates which root the iteration converges to — red, green, and blue correspond to closeness to each of the three roots.  
          Intermediate colors appear where points end up close to more than one root, while very dark regions represent points far from all roots.  
          As the number of iterations increases, most points are drawn toward one of the three roots, dividing the plane into three <strong>basins of attraction</strong>.  
          These basins of attraction are typically disconnected, and the boundaries between them exhibit a highly chaotic, fractal behaviour.
        </p>
      `;

      const desktopInstructions = `
      <p>
        <strong>How to interact (desktop):</strong><br>
        • Two of the roots are fixed in place (black dots).<br>
        • <strong>Right-click</strong> on the image to toggle between <em>Root Placement Mode</em> and <em>Panning Mode</em>.<br>
        • <em>Panning mode:</em> <strong>Click & drag</strong> to pan the view, <strong>scroll</strong> to zoom around the mouse.<br>
        • <em>Root Placement Mode:</em> <strong>Move the mouse</strong> to move the third root (white dot).<br>
        • Use the <strong>Iterations</strong> slider to control the number of Newton iterations.<br>
        • Click <strong>Fullscreen</strong> to view the fractal in immersive mode.
      </p>
      `;

      const mobileInstructions = `
      <p>
        <strong>How to interact (mobile):</strong><br>
        • Two of the roots are fixed in place (black dots).<br>
        • <strong>Move the third root (white dot):</strong> Drag a single finger <em>on top of current third root</em> or <em>double-tap + drag</em> anywhere.<br>
        • <strong>Pan:</strong> Drag with two fingers.<br>
        • <strong>Zoom:</strong> Pinch with two fingers.<br>
        • Use the <strong>iterations</strong> slider to control the number of Newton iterations.<br>
        • Tap <strong>Fullscreen</strong> to view the fractal in immersive mode.
      </p>
      <p>
        <strong>Known issues on mobile:</strong><br>
        • The image may not initially render. Double Tap on the fractal to fix it.<br>
        • Precision may be limited at extreme zooms; for best experience, use desktop.
      </p>
      `;

      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      descriptionEl.innerHTML = baseText + (isMobile ? mobileInstructions : desktopInstructions);

      // -------------------
      // State
      // -------------------
      let interactionMode = 'root'; 
      let zoom = 1.0;
      let pan = [0.0, 0.0];
      let rootPosition = [0.0, 0.0];
      let isDragging = false;
      let lastMousePos = { x: 0, y: 0 };
      let ongoingTouches = [];
      let touchMode = null;
      let touchStartPos = null;

      function getShaderMouse(event) {
        const rect = canvas.getBoundingClientRect();
        const x_css = event.clientX - rect.left;
        const y_css = event.clientY - rect.top;
        const small_resol = Math.min(rect.width, rect.height);
        const uv_x = (2.0 * x_css - rect.width) / small_resol;
        const uv_y = (2.0 * (rect.height - y_css) - rect.height) / small_resol; 
        return [(uv_x * zoom) + pan[0], (uv_y * zoom) + pan[1]];
      }

      function getTouchPos(touch) {
        const rect = canvas.getBoundingClientRect();
        const x_css = touch.clientX - rect.left;
        const y_css = touch.clientY - rect.top;
        const small_resol = Math.min(rect.width, rect.height);
        const uv_x = (2.0 * x_css - rect.width) / small_resol;
        const uv_y = (2.0 * (rect.height - y_css) - rect.height) / small_resol;
        return [(uv_x * zoom) + pan[0], (uv_y * zoom) + pan[1]];
      }

      function resizeToCurrentDisplay() {
        const cssWidth = canvas.clientWidth;
        const cssHeight = canvas.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
        sandbox.resize();
      }

      function handleResize() { resizeToCurrentDisplay(); }

      // -------------------
      // Load shader
      // -------------------
      const fragUrl = new URL(canvas.getAttribute("data-fragment-url"), window.location.href);
      try {
        const response = await fetch(fragUrl, { mode: "same-origin" });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const fragShader = await response.text();
        sandbox.load(fragShader);
        requestAnimationFrame(handleResize);
        sandbox.forceRender && sandbox.forceRender(); // initial render
      } catch (err) {
        console.error("Failed to load shader:", err);
        canvas.getContext("2d").fillText("Error loading shader", 20, 20);
        return;
      }

      sandbox.setUniform("u_iterations", parseInt(slider.value, 10));
      sandbox.setUniform("u_zoom", zoom);
      sandbox.setUniform("u_pan", pan[0], pan[1]);
      sandbox.setUniform("u_root_position", rootPosition[0], rootPosition[1]);
      iterDisplay.textContent = slider.value;

      slider.addEventListener("input", () => {
        const iterations = parseInt(slider.value, 10);
        sandbox.setUniform("u_iterations", iterations);
        iterDisplay.textContent = iterations;
      });

      // -------------------
      // Desktop interactions
      // -------------------
      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault(); 
        if (interactionMode === 'root') {
          interactionMode = 'pan';
          canvas.style.cursor = 'move';
        } else {
          interactionMode = 'root';
          canvas.style.cursor = 'crosshair';
        }
      });

      canvas.addEventListener("mousedown", (e) => {
        if (interactionMode === 'pan' && e.button === 0) {
          isDragging = true;
          lastMousePos = { x: e.clientX, y: e.clientY };
        }
      });

      window.addEventListener("mouseup", (e) => { if (e.button === 0) isDragging = false; });

      window.addEventListener("mousemove", (e) => {
        const [shaderX, shaderY] = getShaderMouse(e);
        if (isDragging && interactionMode === 'pan') {
          const deltaX_css = e.clientX - lastMousePos.x;
          const deltaY_css = e.clientY - lastMousePos.y;
          const rect = canvas.getBoundingClientRect();
          const small_resol = Math.min(canvas.width, canvas.height);
          const deltaX_shader = (deltaX_css * (canvas.width / rect.width) * 2.0 / small_resol) * zoom;
          const deltaY_shader = (deltaY_css * (canvas.height / rect.height) * 2.0 / small_resol) * zoom;
          pan[0] -= deltaX_shader;
          pan[1] += deltaY_shader;
          sandbox.setUniform("u_pan", pan[0], pan[1]);
          lastMousePos = { x: e.clientX, y: e.clientY };
        } else if (interactionMode === 'root') {
          rootPosition = [shaderX, shaderY];
          sandbox.setUniform("u_root_position", shaderX, shaderY);
        }
      });

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault(); 
        if (interactionMode === 'pan') {
          const [mouseX_before, mouseY_before] = getShaderMouse(e);
          const zoomAmount = e.deltaY * 0.005; 
          zoom *= (1.0 + zoomAmount);
          sandbox.setUniform("u_zoom", zoom);
          const [mouseX_after, mouseY_after] = getShaderMouse(e);
          pan[0] += (mouseX_before - mouseX_after);
          pan[1] += (mouseY_before - mouseY_after);
          sandbox.setUniform("u_pan", pan[0], pan[1]);
        }
      });

      // -------------------
      // Mobile interactions (updated)
      // -------------------
      let lastTapTime = 0;
      const doubleTapThreshold = 300; // ms
      const rootTouchRadius = 0.1; // proximity threshold in shader coordinates
      
      function distance2D(a, b) {
        return Math.hypot(a[0] - b[0], a[1] - b[1]);
      }
      
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        ongoingTouches = [...e.touches];
      
        if (ongoingTouches.length === 1) {
          const [x, y] = getTouchPos(ongoingTouches[0]);
          const now = Date.now();
          const timeSinceLastTap = now - lastTapTime;
      
          const dynamicRadius = rootTouchRadius * zoom; // scale with zoom
      
          if (timeSinceLastTap < doubleTapThreshold) {
            touchMode = 'root'; // double-tap + drag
          } else if (distance2D([x, y], rootPosition) < dynamicRadius) {
            touchMode = 'root'; // touch near root, radius depends on zoom
          } else {
            touchMode = null;
          }
      
          touchStartPos = { x: ongoingTouches[0].clientX, y: ongoingTouches[0].clientY };
          lastTapTime = now;
        } else if (ongoingTouches.length === 2) {
          touchMode = 'pan';
        }
      });
            
      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (e.touches.length === 2) touchMode = 'pan';
      
        if (touchMode === 'root' && e.touches.length === 1) {
          const [x, y] = getTouchPos(e.touches[0]);
          rootPosition = [x, y];
          sandbox.setUniform("u_root_position", x, y);
        } else if (touchMode === 'pan' && e.touches.length === 2) {
          const t0 = e.touches[0];
          const t1 = e.touches[1];
          const prevT0 = ongoingTouches[0];
          const prevT1 = ongoingTouches[1];
      
          const prevDist = Math.hypot(prevT0.clientX - prevT1.clientX, prevT0.clientY - prevT1.clientY);
          const newDist = Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
          const zoomFactor = prevDist / newDist;
          zoom *= zoomFactor;
      
          const prevMidX = (prevT0.clientX + prevT1.clientX)/2;
          const prevMidY = (prevT0.clientY + prevT1.clientY)/2;
          const newMidX = (t0.clientX + t1.clientX)/2;
          const newMidY = (t0.clientY + t1.clientY)/2;
      
          const rect = canvas.getBoundingClientRect();
          const small_resol = Math.min(rect.width, rect.height);
          const deltaX_shader = ((newMidX - prevMidX) * 2.0 / small_resol) * zoom;
          const deltaY_shader = ((newMidY - prevMidY) * 2.0 / small_resol) * zoom;
      
          pan[0] -= deltaX_shader;
          pan[1] += deltaY_shader;
      
          sandbox.setUniform("u_zoom", zoom);
          sandbox.setUniform("u_pan", pan[0], pan[1]);
        }
      
        ongoingTouches = [...e.touches];
      });

      // -------------------
      // Fullscreen
      // -------------------
      function reapplyState() {
        sandbox.setUniform("u_iterations", parseInt(slider.value, 10));
        sandbox.setUniform("u_zoom", zoom);
        sandbox.setUniform("u_pan", pan[0], pan[1]);
        sandbox.setUniform("u_root_position", rootPosition[0], rootPosition[1]);
        requestAnimationFrame(() => sandbox.forceRender && sandbox.forceRender());
      }
      
      async function toggleFullscreen() {
        if (!document.fullscreenElement) {
          await canvas.requestFullscreen();
        } else {
          await document.exitFullscreen();
        }
      }
      
      fullscreenBtn.addEventListener("click", toggleFullscreen);
      
      document.addEventListener("fullscreenchange", () => {
        fullscreenBtn.textContent = document.fullscreenElement ? "Exit Fullscreen" : "Fullscreen";
        setTimeout(() => { resizeToCurrentDisplay(); reapplyState(); }, 150);
      });

      window.addEventListener("resize", handleResize);

      // -------------------
      // Fix for mobile blank canvas
      // -------------------
      function ensureCanvasRenders() { sandbox.forceRender && sandbox.forceRender(); }

      function firstInteractionHandler() {
        ensureCanvasRenders();
        window.removeEventListener('touchstart', firstInteractionHandler);
        window.removeEventListener('mousedown', firstInteractionHandler);
      }

      window.addEventListener('touchstart', firstInteractionHandler, { once: true });
      window.addEventListener('mousedown', firstInteractionHandler, { once: true });

    });
  </script>
</body>
</html>
