---
layout: default
title: Newton's Fractal
---

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

  <style>
    body {
      text-align: center;
      margin: 0;
      padding: 2em;
      overflow-y: auto;
      overflow-x: hidden;
    }

    nav {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
    }

    .shader-window {
      max-width: 800px;
      margin: 0 auto;
    }

    canvas {
      display: block;
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 0.5em;
      cursor: crosshair;
      touch-action: none;
    }

    .controls {
      margin-top: 1em;
    }

    .description {
      max-width: 800px;
      margin: 1em auto 2em auto;
      font-size: 0.95em;
      line-height: 1.5em;
      text-align: left;
    }

    button {
      padding: 0.4em 0.8em;
      border-radius: 0.3em;
      cursor: pointer;
      margin-top: 0.5em;
      font-size: 0.9em;
      transition: background 0.2s;
    }

    canvas:fullscreen {
      width: 100vw !important;
      height: 100vh !important;
      border-radius: 0;
    }
  </style>
</head>

<body>
  <nav>
    <a href="../index.html">&larr; About Me</a>
  </nav>

  <h1>Newton's Fractal</h1>

  <div class="description" id="description"></div>

  <div class="shader-window">
    <canvas class="glslCanvas" data-fragment-url="shader.frag"></canvas>
  </div>

  <div class="controls">
    <label for="iterSlider">Iterations:</label>
    <input type="range" id="iterSlider" min="0" max="50" value="10" />
    <span id="iterValue">10</span><br />
    <button id="fullscreenBtn">Fullscreen</button>
  </div>

  <script type="module">
    import GlslCanvas from "https://esm.run/glslCanvas";

    window.addEventListener("load", async () => {
      const canvas = document.querySelector(".glslCanvas");
      const slider = document.getElementById("iterSlider");
      const iterDisplay = document.getElementById("iterValue");
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      const descriptionEl = document.getElementById("description");
      const sandbox = new GlslCanvas(canvas);

      // ----- UI text -----
      const baseText = `
        <p>
          This visualization shows the <strong>Newton fractal</strong> for a cubic polynomial with three roots (black dots).
          Each pixel is iterated using Newton’s method, and color indicates which root the iteration converges to.
          The boundaries between colors form the characteristic fractal structure.
        </p>
      `;

      const desktopInstructions = `
        <p><strong>Desktop controls:</strong><br>
        • Starts in <em>Pan mode</em> — click and drag to move, scroll to zoom.<br>
        • Right-click to toggle between <em>Pan</em> and <em>Root placement</em> mode.<br>
        • In <em>Root mode</em>, move the mouse to position the third root (white dot).<br>
        • Use the slider for iteration count; click Fullscreen for immersive view.
        </p>
      `;

      const mobileInstructions = `
        <p><strong>Mobile controls:</strong><br>
        • Drag the white dot or double-tap + drag to move the third root.<br>
        • Two-finger drag to pan, pinch to zoom.<br>
        • Adjust iterations with the slider; tap Fullscreen for immersive view.<br>
        • If it doesn’t render at first, double-tap the fractal.
        </p>
      `;

      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      descriptionEl.innerHTML = baseText + (isMobile ? mobileInstructions : desktopInstructions);

      // ----- State -----
      let interactionMode = isMobile ? "root" : "pan";
      canvas.style.cursor = isMobile ? "crosshair" : "move";
      let zoom = 1.0;
      let pan = [0.0, 0.0];
      let rootPosition = [0.0, 1.0]; // start at 0 + 1i
      let isDragging = false;
      let lastMousePos = { x: 0, y: 0 };
      let lastTouchDist = null;
      let lastTouchMid = null;

      function resizeToCurrentDisplay() {
        const cssWidth = canvas.clientWidth;
        const cssHeight = canvas.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
        sandbox.resize();
      }

      function getShaderCoords(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const x_css = clientX - rect.left;
        const y_css = clientY - rect.top;
        const small_res = Math.min(rect.width, rect.height);
        const uv_x = (2 * x_css - rect.width) / small_res;
        const uv_y = (2 * (rect.height - y_css) - rect.height) / small_res;
        return [(uv_x * zoom) + pan[0], (uv_y * zoom) + pan[1]];
      }

      const fragUrl = new URL(canvas.dataset.fragmentUrl, window.location.href);
      const resp = await fetch(fragUrl);
      const shader = await resp.text();
      sandbox.load(shader);

      requestAnimationFrame(() => {
        resizeToCurrentDisplay();
        sandbox.setUniform("u_iterations", +slider.value);
        sandbox.setUniform("u_zoom", zoom);
        sandbox.setUniform("u_pan", pan[0], pan[1]);
        sandbox.setUniform("u_root_position", rootPosition[0], rootPosition[1]);
        if (sandbox.render) sandbox.render();
      });

      // ----- Iter slider -----
      slider.addEventListener("input", () => {
        sandbox.setUniform("u_iterations", +slider.value);
        iterDisplay.textContent = slider.value;
        if (sandbox.render) sandbox.render();
      });

      // ----- Desktop mouse -----
      if (!isMobile) {
        canvas.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          if (interactionMode === "root") {
            interactionMode = "pan";
            canvas.style.cursor = "move";
          } else {
            interactionMode = "root";
            canvas.style.cursor = "crosshair";
          }
        });

        canvas.addEventListener("mousedown", (e) => {
          if (interactionMode === "pan" && e.button === 0) {
            isDragging = true;
            lastMousePos = { x: e.clientX, y: e.clientY };
          }
        });

        window.addEventListener("mouseup", () => (isDragging = false));

        canvas.addEventListener("mousemove", (e) => {
          if (interactionMode === "root") {
            const [sx, sy] = getShaderCoords(e.clientX, e.clientY);
            rootPosition = [sx, sy];
            sandbox.setUniform("u_root_position", sx, sy);
            if (sandbox.render) sandbox.render();
          } else if (isDragging) {
            const rect = canvas.getBoundingClientRect();
            const dx = e.clientX - lastMousePos.x;
            const dy = e.clientY - lastMousePos.y;
            const small_res = Math.min(canvas.width, canvas.height);
            pan[0] -= (dx * (canvas.width / rect.width) * 2 / small_res) * zoom;
            pan[1] += (dy * (canvas.height / rect.height) * 2 / small_res) * zoom;
            sandbox.setUniform("u_pan", pan[0], pan[1]);
            lastMousePos = { x: e.clientX, y: e.clientY };
            if (sandbox.render) sandbox.render();
          }
        });

        canvas.addEventListener("wheel", (e) => {
          e.preventDefault();
          const [beforeX, beforeY] = getShaderCoords(e.clientX, e.clientY);
          zoom *= 1 + e.deltaY * 0.005;
          sandbox.setUniform("u_zoom", zoom);
          const [afterX, afterY] = getShaderCoords(e.clientX, e.clientY);
          pan[0] += beforeX - afterX;
          pan[1] += beforeY - afterY;
          sandbox.setUniform("u_pan", pan[0], pan[1]);
          if (sandbox.render) sandbox.render();
        });
      }

      // ----- Mobile touch -----
      if (isMobile) {
        canvas.addEventListener("touchstart", (e) => {
          if (e.touches.length === 1) {
            isDragging = true;
            lastTouchMid = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastTouchDist = Math.hypot(dx, dy);
            lastTouchMid = {
              x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
              y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
            };
          }
        });

        canvas.addEventListener("touchmove", (e) => {
          e.preventDefault();
          if (e.touches.length === 1 && isDragging) {
            const [sx, sy] = getShaderCoords(e.touches[0].clientX, e.touches[0].clientY);
            rootPosition = [sx, sy];
            sandbox.setUniform("u_root_position", sx, sy);
            if (sandbox.render) sandbox.render();
          } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const newDist = Math.hypot(dx, dy);
            const mid = {
              x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
              y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
            };
            if (lastTouchDist) {
              const zoomFactor = lastTouchDist / newDist;
              zoom *= zoomFactor;
              sandbox.setUniform("u_zoom", zoom);
              const [beforeX, beforeY] = getShaderCoords(lastTouchMid.x, lastTouchMid.y);
              const [afterX, afterY] = getShaderCoords(mid.x, mid.y);
              pan[0] += beforeX - afterX;
              pan[1] += beforeY - afterY;
              sandbox.setUniform("u_pan", pan[0], pan[1]);
              if (sandbox.render) sandbox.render();
            }
            lastTouchDist = newDist;
            lastTouchMid = mid;
          }
        });

        canvas.addEventListener("touchend", () => {
          isDragging = false;
          lastTouchDist = null;
          lastTouchMid = null;
        });

        // fix blank render
        canvas.addEventListener("dblclick", () => {
          if (sandbox.render) sandbox.render();
        });
      }

      // ----- Fullscreen -----
      async function toggleFullscreen() {
        if (!document.fullscreenElement) {
          await canvas.requestFullscreen();
        } else {
          await document.exitFullscreen();
        }
      }

      fullscreenBtn.addEventListener("click", toggleFullscreen);
      document.addEventListener("fullscreenchange", () => {
        fullscreenBtn.textContent = document.fullscreenElement
          ? "Exit Fullscreen"
          : "Fullscreen";
        setTimeout(() => {
          resizeToCurrentDisplay();
          sandbox.setUniform("u_zoom", zoom);
          sandbox.setUniform("u_pan", pan[0], pan[1]);
          sandbox.setUniform("u_root_position", rootPosition[0], rootPosition[1]);
          sandbox.setUniform("u_iterations", +slider.value);
          if (sandbox.render) sandbox.render();
        }, 150);
      });

      window.addEventListener("resize", resizeToCurrentDisplay);
    });
  </script>
</body>
</html>
